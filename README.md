# Вопросы к собеседованию по Java, Kotlin & Spring

## Java 

### ООП

#### Абстракция:
> Абстракция - это выделение свойств (полей) и действий (методов) описываемой модели необходимых для решения данной задачи и опускание других свойств/действий.

#### Инкапсуляция:
> Инкапсуляция - это сокрытие сложностей внутренней реализации модели и предоставление простого и понятного интерфейса пользователю.
```java
class SomeComplexClass {
    
    private Object field1;
    private Object field2;
//   ...
    private Object fieldN;
    
    private void someComplexMethod1(/*args*/) {
//        complex logic
    }
    private void someComplexMethod2(/*args*/) {
//        complex logic
    }
//    ...
    private void someComplexMethodN(/*args*/) {
//        complex logic
    }
    
//    Сложности реализации объекта скрываются, а пользователю предоставляется простой интерфейс
    public void smartMethod(Object obj){
        someComplexMethod1(/*args*/);
        someComplexMethod2(/*args*/);
//        ...
        someComplexMethodN(/*args*/);
    }
    
}
```

#### Наследование:
> Наследование - это свойство перенимать состояние (поля) и поведение (методы) родительского класса.

```java
class Animal {
    int age;
    int weight;
    
    public void eat(){}
}

class Person extends Animal {
    String name;
    
    public void introduceAndEat(){
        System.out.println("Hello, my name is " + name + ", my age is " + age + ", my weight is " + weigth +
                " and now I am going to eat!");
        eat();
    }
}

```

#### Полиморфизм:
> Полиморфизм: способность метода обрабатывать параметры разных типов, взаимодействуя с ними по родительскому интерфейсу.

```java

public class Clazz {
    
    public static void main(String[]args){
        List immutableList = Arrays.asList("a", "b", "c");
        List arrayList = new ArrayList();
        List linkedList = new LinkedList();
        
//        независимо от объекта, которым является параметр метода,
//        если он реализует интерфейс List, метод его примет и корректно обработает
        method(immutableList);
        method(arrayList);
        method(linkedList);
    }
    
//    также к полиморфизму можно отнести перегрузку методов
    public static void method(List list) {}
    public static void method(List list, int max) {}
    public static void method(List list, int max, int min) {}
}

```

### Типы данных, классы, объекты, интерфейсы, абстрактные классы, static

#### Примитивные типы данных 

##### Целочисленные
- byte - целое число от -128 до 127 (8 бит)
- short - целое число от -32768 до 32767 (16 бит)
- char - беззнаковое целое число, представляющее собой символ UTF-16 (буквы и цифры, 16 бит)
- int - целое число от -2147483648 до 2147483647 (32 бита)
- long - целое число от -9223372036854775808L до 9223372036854775807L (64 бита)

##### С плавающей точкой 
- float - действительное число от 1.4e-45f до 3.4e+38f (32 бита)
- double - действительное число от 4.9e-324 до 1.7e+308 (64 бита)

##### Логический
- boolean - true/false (32 бита везде, кроме массивов, там 8 бит)

#### Ссылочные типы данных 
> Все остальные типы, начиная от *Object*

#### Класс
> Класс - это прототип (шаблон) некой сущности

#### Объект 
> Объект - это конкретный экземпляр класса

#### Интерфейс
> Интерфейс - это контракт, который обязуются соблюдать реализующие его классы.

Реализует взаимоотношение "*ведет себя как*".
Интерфейс может иметь:
- методы (по умолчанию - абстрактные, без реализации)
- final static поля 
- начиная с Java 8 - дефолтные методы с реализацией по-умолчанию

#### Абстрактный класс
> Абстрактный класс - класс, создание экземпляров которого невозможно. 

Реализует взаимоотношение "*является*" (is-a). 
Абстрактный класс может иметь:
- поля, в т.ч. нестатические 
- методы, в т.ч. абстрактные

#### Интерфейс vs. Абстрактный класс

Наследование абстрактного класса образует гораздо более *сильную связь* с родителем, чем реализация интерфейса.
То есть при создании класса-наследника под капотом сначала вызывается конструктор класса-родителя,
инициализируются все его поля, а потом создается класс-наследник.

Интерфейс же просто регламентирует обязательное поведение классов, которые его реализуют.

> Таким образом, для поддержания более низкой связности системы **рекомендуется использовать реализацию интерфейсов во всех случаях**,
кроме тех, где нужно выстроить явную иерархию с отношением "*является*".


#### static
> Ключевое слово static означает принадлежность поля/метода/класса не к *объекту*, а к *классу*. 

В случае с полем это означает что существует только 1 экземпляр этого поля на всю программу и можно получить к нему доступ,
не создавая объект класса, в котором описано это поле, через имя класса (Class.staticField). 

В случае с методом это означает что этот метод может использовать только другие статические методы и можно получить к нему доступ,
не создавая объект класса, в котором описан этот метод, через имя класса (Class.staticMethod()).

### Классы String, Object


### Методы equals(), hashcode(), контракт между ними.

### Коллекции - иерархия, базовые интерфейсы, ArrayList/LinkedList/HashMap/HashSet под капотом, сложности операций над ними

### Исключения - иерархия, виды.

### Функциональные интерфейсы. Stream API, основные операторы методы

### Основы многопоточности. Thread, synchronized, volatile, классы Atomic

## Kotlin

### Val/var

### Extension функции, как компилируются в джаве

### Null safety

### Классы Any, Unit, Nothing(+чьим наследником является класс Nothing) .

### With, let, apply, run

### Чем плохо последовательное использование map/filter/… на коллекциях?Как исправить?

### Data класс, свойства. Чем плохо использование Data как JPA Entity

### Companion object

### Object-класс, свойства

## Spring

### Принцип работы, DI, IoC.

### Способы конфигурации Spring-приложения.

### Что такое Spring bean? Какие есть способы внедрить bean? Bean scope.

### Как в Spring используется паттерн Proxy? механизм AOP

### Аннотации @Bean, @Component, @ComponentScan

### Spring vs Spring boot

### Spring MVC - что это, основные аннотации.

### Spring Data JPA - что это, основные аннотации, преимущества/недостатки, FetchType, Cascade, проблема n+1,

### тонкости работы @Transactional

### Kafka: Принцип работы, плюсы по сравнению с синхронными вызовами. Реализация в Spring

## Common
